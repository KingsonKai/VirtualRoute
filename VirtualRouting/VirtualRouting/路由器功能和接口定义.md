## 路由器功能和接口定义

#### 功能

先明白一个概念

心跳侦测包的概念：心跳侦测包顾名思义，就是侦测别的路由器是否还存活着，如果存活，说明有心跳。每个路由器会定时（2s）发送给其他的路由器一个心跳侦测包，其他路由器接收到后，发送回响信息表明还在运行，如果没有收到回响，说明这个路由器已经down掉，那么此时就要修改路由表，把这个路由器设置为不可达。

路由信息报文：发送一个报文，把自身的路由表或者是自己周边的链路状态发送给其他路由器。

普通报文：区别于以上两个报文，数据信息未知，这类报文我们在这里不做其他处理，只要输出即可，不用做多余的处理。有可能只是一个测试报文而已



首先界定路由表的功能如下

1. 接收数据包并且回应，回应的意思就是返回一条响应给发送端

   可以举例如下： A发送数据包给B，A此时等待接收B可能发过来的消息。B接收包后，发送响应responseMessage给A，A收到后，输出到界面上，到时候调试的时候才可以看到是否接收成功。

   再比如，收到心跳侦测包等等包的时候，必须回应给发送端一个消息表明自己还存活着。

   这里有一个例外，发送路由信息时，无需等待回响。路由信息只要发出去就发出去了，不用有回响信息。

2. 发送心跳侦测包和路由信息

   过程如下：

   * 发送包，等待接收响应（心跳侦测包）
   * 对于路由信息，发送完就不用管回响了。
   * 心跳侦测包还必须等待接收响应，如果没有响应说明主机已经down掉，此时要更新路由表的信息，调用相应的函数。同时，更新路由表完毕后，还要发送路由信息给邻居或者给其他所有主机（区分LS和DV）

3. 解析数据包信息

   路由器会收到三种形式的数据报文

   * 普通的数据报文
   * 路由信息报文
   * 心跳侦测包

   每个报文格式如下：

   | 第0位       | 1-15位 | 17-31位 | 33-最后一位 |
   | --------- | ----- | ------ | ------- |
   | type，报文类型 | 源IP地址 | 目的IP地址 | 数据信息    |

   IP地址、数据信息之间有'*'隔开，比如说

   ```
   0192.168.111.111*192.168.111.112*what are you doing?
   ```

   注意，每个IP地址都是15位，不足15位的用0补全。

   ```
   1192.168.111.111*192.168.001.002*192.168.111.00210*192.168.111.00305*
   ```

   * 类型1是路由信息报文，路由信息报文的数据部分有所不同。（前面格式相同，就是数据部分有规定）

   格式一般如下：

   | 目的IP地址 | 开销          | 以*符号隔开不同的路由信息 |
   | ------ | ----------- | ------------- |
   | 15位    | 2位（0-99的数值） | 1位            |

```
192.168.111.00210 代表到目的网咯192.168.111.002的开销是10
```

​	路由信息发完是不需要等待接收”我已经收到“这类信息的	



* 类型2是心跳侦测包

  ```
  2192.168.111.111*192.168.111.112*Are you alive?
  ```

  比较简单，其实我们只要检测到type=2，且目的主机是自己，那么就返回一个信息“I am alive!"

### 重点和关键点

1. 收到数据包后，首先检查是否是传给自己的数据包，如果不是传给自己的，那么要做转发操作
2. 收到心跳侦测包回响和路由表信息后，若有更新，一定要调用对应算法。并且看下是否需要返回给源主机一些信息
3. 收到路由表信息后，提取出字符串里的路由信息，解析后，要根据RoutertableLS或者DV做相应的操作（解析后如何使得数据传过去更新RouterTable呢？），以使得算法能高效方便的运行。


我在controller（其实就相当于一服务器）里面定义了handlePacket（有好几种）函数，根据这些函数实现功能。（如果有需要修改也可以修改，毕竟不一定是合适的API）



#### 路由表更新过程

首先看一下RoutetableLS\RoutetableDV的函数声明，看传进去的是什么来更新代码。

这里比较重要，我详细说。

LS算法需要保存整个网络拓补图，简单来讲，我们这个拓补图有12条链路（指实际存在的链路，拓补图有多少条就多少），那么LS算法需要把这12条链路（源、目的地址，开销）保存进一个数组，我们假设这个数组叫做 networkGraph，通过这个networkGraph运行算法，计算出路由表，路由表命名为 routetable

DV算法需要保存自身 + 邻居 的路由表（不是链路，只要把各自的路由表里的信息存下来就行了，存源IP、目的IP，开销即可，不用存下一跳路由器）。都存在一个数组里面，假设为 neighborsRouteTables。（具体数组如何定义，到RoutetableLS\RoutetableDV代码查看）。

好，定义完以上消息，我们来看controller如何和这部分交互。

初始化完毕后，如果收到了路由信息：

对于LS算法：

1. 查看是否需要修改网络拓补图networkGraph，如果修改了，那么调用算法更新路由表routetable，然后给其他路由器发送更新信息（这里的路由信息，不是指路由表，而是把这个网络拓补图发过去networkGraph）
2. 如果没有修改，那么也不用调用算法，不需要给其他路由器发送信息

对于DV算法：

1. 查看是否需要修改neighborRouteTables，如果需要，修改，然后调用算法更新路由表routetable，发送路由信息给邻居（发送路由表信息routetable）
2. 如果没有修改，一样也不用做什么操作了



####路由信息举例：

主机A（192.168.111.001）的路由表如下

| 目的IP地址          | 开销   | nexthop         |
| --------------- | ---- | --------------- |
| 192.168.111.002 | 1    | 192.168.111.005 |
| 192.168.111.003 | 2    | 192.168.111.006 |
| 192.168.111.004 | 3    | 192.168.111.007 |

那么，A会发送给邻居 B C，以下报文

192.168.111.002  01 * 192.168.111.003 02 * 192.168.111.004 03

目的IP地址 + 开销 + * + 另一个路由信息